---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
library(tidyverse)
```
# triplib

CAUTION, triplib is very much in-development and has not been extensively checked. 

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![Travis build status](https://travis-ci.org/Trackage/triplib.svg?branch=master)](https://travis-ci.org/Trackage/triplib)
[![AppVeyor build status](https://ci.appveyor.com/api/projects/status/github/Trackage/triplib?branch=master&svg=true)](https://ci.appveyor.com/project/Trackage/triplib)
[![Codecov test coverage](https://codecov.io/gh/Trackage/triplib/branch/master/graph/badge.svg)](https://codecov.io/gh/Trackage/triplib?branch=master)
<!-- badges: end -->

The goal of triplib is to provide shared tools for tracking data. 

There is a huge fragmentation of tools and approaches in R for tracking, see the Spatio-Temporal 
Task View section for examples. 

We would like to have a simple core package to provide the most commonly used metrics. We assume `geodist` and `geosphere` as good examples of core packages for the underlying tool. 


* `track_distance()` for distance in metres
* `track_angle()` for internal angle in degrees
* `track_turn()` for relative turn angle
* `track_bearing()` for absolute bearing
* `track_time()` for duration in seconds
* `track_speed()` for speed in metres per second
* `track_distance_to()` for distance to location
* `track_bearing_to()` for bearing to location

Distances are always returned in metres. 

Angles are always returned in degrees, and absolute bearing is relative to North (0), and proceeds clockwise positive and anti-clockwise negative `N = 0, E = 90, S = +/-180, W = -90`. 

Time is always returned in seconds. 


## Installation

Not available on CRAN yet. 

You can install the  development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("Trackage/triplib")
```
## Example

This is a basic example which shows you how to calculate ellipsoidal distance and turning angle for a data set of tracks. 

First, calculate without any groupings - we definitely don't want this as there are three separate tracks within our data set identified by `id`. (No ordering is a applied other than the order the rows occur).

```{r example}
library(triplib)

library(tidyverse)
## there's no grouping here - we haven't gotten our data organized yet
trips0 %>% mutate(distance = track_distance(x, y), angle = track_angle(x, y))

```
Now run the same metrics but do it with respect to the grouping variable `id`. 


TODO: show clearly the nonsense values we get if grouping is not respected. 

```{r example-group_by}
## now we group by id (also need arrange by date to be sure ...)
metric <- trips0 %>% group_by(id) %>% mutate(distance = track_distance(x, y), 
                                             angle = track_angle(x, y),
                                             turn = track_turn(x, y), 
                                             bearing = track_bearing(x, y), 
                                             duration = track_time(date),
                                             speed = track_speed(x, y, date), 
                                             distance_to = track_distance_to(x, y, 147, -42), 
                                             bearing_to = track_bearing_to(x, y, 100, -42)) 
metric 

metric %>% 
  ggplot(aes(x, y, cex= 1/angle)) + 
  geom_point() + 
  geom_path(col = rgb(0.2, 0.2, 0.2, 0.2))

metric %>% 
  ggplot(aes(x, y, colour = distance_to)) + 
  geom_point() + geom_label(data = data.frame(x = 147, y = -42, distance_to = 0), 
                            label = "home")

metric %>% 
  ggplot(aes(x, y, colour = bearing_to)) + 
  geom_point() + geom_label(data = data.frame(x = 100, y = -42, bearing_to = 0), 
                            label = "home")


```

Using the bearing and distance now reproduce the track as *destination point* segments. 

```{r dest-point}
plot(metric[1:10, c("x", "y")], type = "b", lwd = 10, col = "grey")
dest <- geosphere::destPoint(metric[1:10, c("x", "y")], 
                             b = metric$bearing[1:10], 
                            d = metric$distance[2:11])
arrows(metric$x[1:10], metric$y[1:10], dest[1:10,1], dest[1:10,2], col = "firebrick", lwd = 2)
```



---

Please note that the 'triplib' project is released with a
[Contributor Code of Conduct](CODE_OF_CONDUCT.md).
By contributing to this project, you agree to abide by its terms.

